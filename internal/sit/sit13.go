/*
StuffIt file archiver client

XAD library system for archive handling
Copyright (C) 1998 and later by Dirk Stoecker <soft@dstoecker.de>

little based on macutils 2.0b3 macunpack by Dik T. Winter
Copyright (C) 1992 Dik T. Winter <dik@cwi.nl>

algorithm 15 is based on the work of  Matthew T. Russotto
Copyright (C) 2002 Matthew T. Russotto <russotto@speakeasy.net>
http://www.speakeasy.org/~russotto/arseniccomp.html

ported to Go
Copyright (C) 2025 Elliot Nunn

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package sit

import (
	"bufio"
	"encoding/hex"
	"fmt"
	"io"
)

type SIT13Buffer struct {
	data uint16
	bits int8
}

type SIT13Store struct {
	freq int16
	d1   uint16
	d2   uint16
}

var Buffer1 [0x1000]SIT13Buffer

type SIT13Data struct {
	br       *bufio.Reader
	MaxBits  uint16
	Buffer4  [0xE08]SIT13Store
	Buffer2  [0x1000]SIT13Buffer
	Buffer3  [0x1000]SIT13Buffer
	Buffer3b [0x1000]SIT13Buffer
	Buffer5  [0x141]SIT13Buffer
	TextBuf  [658]uint8
	Window   [0x10000]uint8
}

func (s *SIT13Data) print() {
	fmt.Printf("numbits = %04x\n", s.MaxBits)
	do1 := func(name string, slice []SIT13Store) {
		for i, b := range slice {
			fmt.Printf("%s[%d] = (%d,%04x,%04x)\n", name, i, b.freq, b.d1, b.d2)
		}
	}
	do2 := func(name string, slice []SIT13Buffer) {
		for i, b := range slice {
			fmt.Printf("%s[%d] = (%04x,%02x)\n", name, i, b.data, uint8(b.bits))
		}
	}
	do1("Buffer4", s.Buffer4[:])
	do2("Buffer1", Buffer1[:])
	do2("Buffer2", s.Buffer2[:])
	do2("Buffer3", s.Buffer3[:])
	do2("Buffer3b", s.Buffer3b[:])
	do2("Buffer5", s.Buffer5[:])
	fmt.Println("TextBuf")
	fmt.Println("    " + hex.EncodeToString(s.TextBuf[:]))
}

var SIT13Bits = [16]uint8{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}
var SIT13Info = [37]uint16{
	0x5D8, 0x058, 0x040, 0x0C0, 0x000, 0x078, 0x02B, 0x014,
	0x00C, 0x01C, 0x01B, 0x00B, 0x010, 0x020, 0x038, 0x018,
	0x0D8, 0xBD8, 0x180, 0x680, 0x380, 0xF80, 0x780, 0x480,
	0x080, 0x280, 0x3D8, 0xFD8, 0x7D8, 0x9D8, 0x1D8, 0x004,
	0x001, 0x002, 0x007, 0x003, 0x008,
}
var SIT13InfoBits = [37]uint16{
	11, 8, 8, 8, 8, 7, 6, 5, 5, 5, 5, 6, 5, 6, 7, 7,
	9, 12, 10, 11, 11, 12, 12, 11, 11, 11, 12, 12, 12, 12, 12, 5,
	2, 2, 3, 4, 5,
}
var SIT13StaticPos = [5]uint16{0, 330, 661, 991, 1323}
var SIT13StaticBits = [5]uint8{11, 13, 14, 11, 11}
var SIT13Static = [1655]uint8{
	0xB8, 0x98, 0x78, 0x77, 0x75, 0x97, 0x76, 0x87, 0x77, 0x77, 0x77, 0x78, 0x67, 0x87, 0x68, 0x67, 0x3B, 0x77, 0x78, 0x67,
	0x77, 0x77, 0x77, 0x59, 0x76, 0x87, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x76, 0x87, 0x67, 0x87, 0x77, 0x77, 0x75, 0x88,
	0x59, 0x75, 0x79, 0x77, 0x78, 0x68, 0x77, 0x67, 0x73, 0xB6, 0x65, 0xB6, 0x76, 0x97, 0x67, 0x47, 0x9A, 0x2A, 0x4A, 0x87,
	0x77, 0x78, 0x67, 0x86, 0x78, 0x77, 0x77, 0x77, 0x68, 0x77, 0x77, 0x77, 0x68, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,
	0x68, 0x77, 0x77, 0x77, 0x67, 0x87, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x68, 0x77, 0x77, 0x68, 0x77, 0x77, 0x77,
	0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x68, 0x77, 0x77, 0x77, 0x77, 0x77, 0x67, 0x87,
	0x68, 0x77, 0x77, 0x77, 0x68, 0x77, 0x68, 0x63, 0x86, 0x7A, 0x87, 0x77, 0x77, 0x87, 0x76, 0x87, 0x77, 0x77, 0x77, 0x77,
	0x77, 0x77, 0x77, 0x77, 0x77, 0x76, 0x86, 0x77, 0x86, 0x86, 0x86, 0x86, 0x87, 0x76, 0x86, 0x87, 0x67, 0x74, 0xA7, 0x86,
	0x36, 0x88, 0x78, 0x76, 0x87, 0x76, 0x96, 0x87, 0x77, 0x84, 0xA6, 0x86, 0x87, 0x76, 0x92, 0xB5, 0x94, 0xA6, 0x96, 0x85,
	0x78, 0x75, 0x96, 0x86, 0x86, 0x75, 0xA7, 0x67, 0x87, 0x85, 0x87, 0x85, 0x95, 0x77, 0x77, 0x85, 0xA3, 0xA7, 0x93, 0x87,
	0x86, 0x94, 0x85, 0xA8, 0x67, 0x85, 0xA5, 0x95, 0x86, 0x68, 0x67, 0x77, 0x96, 0x78, 0x75, 0x86, 0x77, 0xA5, 0x67, 0x87,
	0x85, 0xA6, 0x75, 0x96, 0x85, 0x87, 0x95, 0x95, 0x87, 0x86, 0x94, 0xA5, 0x86, 0x85, 0x87, 0x86, 0x86, 0x86, 0x86, 0x77,
	0x67, 0x76, 0x66, 0x9A, 0x75, 0xA5, 0x94, 0x97, 0x76, 0x96, 0x76, 0x95, 0x86, 0x77, 0x86, 0x87, 0x75, 0xA5, 0x96, 0x85,
	0x86, 0x96, 0x86, 0x86, 0x85, 0x96, 0x86, 0x76, 0x95, 0x86, 0x95, 0x95, 0x95, 0x87, 0x76, 0x87, 0x76, 0x96, 0x85, 0x78,
	0x75, 0xA6, 0x85, 0x86, 0x95, 0x86, 0x95, 0x86, 0x45, 0x69, 0x78, 0x77, 0x87, 0x67, 0x69, 0x58, 0x79, 0x68, 0x78, 0x87,
	0x78, 0x66, 0x88, 0x68, 0x68, 0x77, 0x76, 0x87, 0x68, 0x68, 0x69, 0x58, 0x5A, 0x4B, 0x76, 0x88, 0x69, 0x67, 0xA7, 0x70,
	0x9F, 0x90, 0xA4, 0x84, 0x77, 0x77, 0x77, 0x89, 0x17, 0x77, 0x7B, 0xA7, 0x86, 0x87, 0x77, 0x68, 0x68, 0x69, 0x67, 0x78,
	0x77, 0x78, 0x76, 0x87, 0x77, 0x76, 0x73, 0xB6, 0x87, 0x96, 0x66, 0x87, 0x76, 0x85, 0x87, 0x78, 0x77, 0x77, 0x86, 0x77,
	0x86, 0x78, 0x66, 0x76, 0x77, 0x87, 0x86, 0x78, 0x76, 0x76, 0x86, 0xA5, 0x67, 0x97, 0x77, 0x87, 0x87, 0x76, 0x66, 0x59,
	0x67, 0x59, 0x77, 0x6A, 0x65, 0x86, 0x78, 0x94, 0x77, 0x88, 0x77, 0x78, 0x86, 0x86, 0x76, 0x88, 0x76, 0x87, 0x67, 0x87,
	0x77, 0x77, 0x76, 0x87, 0x86, 0x77, 0x77, 0x77, 0x86, 0x86, 0x76, 0x96, 0x77, 0x77, 0x76, 0x78, 0x86, 0x86, 0x86, 0x95,
	0x86, 0x96, 0x85, 0x95, 0x86, 0x87, 0x75, 0x88, 0x77, 0x87, 0x57, 0x78, 0x76, 0x86, 0x76, 0x96, 0x86, 0x87, 0x76, 0x87,
	0x86, 0x76, 0x77, 0x86, 0x78, 0x78, 0x57, 0x87, 0x86, 0x76, 0x85, 0xA5, 0x87, 0x76, 0x86, 0x86, 0x85, 0x86, 0x53, 0x98,
	0x78, 0x78, 0x77, 0x87, 0x79, 0x67, 0x79, 0x85, 0x87, 0x69, 0x67, 0x68, 0x78, 0x69, 0x68, 0x69, 0x58, 0x87, 0x66, 0x97,
	0x68, 0x68, 0x76, 0x85, 0x78, 0x87, 0x67, 0x97, 0x67, 0x74, 0xA2, 0x28, 0x77, 0x78, 0x77, 0x77, 0x78, 0x68, 0x67, 0x78,
	0x77, 0x78, 0x68, 0x68, 0x77, 0x59, 0x67, 0x5A, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x67, 0x77, 0x78, 0x68, 0x68, 0x78,
	0x59, 0x58, 0x76, 0x77, 0x68, 0x78, 0x68, 0x59, 0x69, 0x58, 0x68, 0x68, 0x67, 0x78, 0x77, 0x78, 0x69, 0x58, 0x68, 0x57,
	0x78, 0x67, 0x78, 0x76, 0x88, 0x58, 0x67, 0x7A, 0x46, 0x88, 0x77, 0x78, 0x68, 0x68, 0x66, 0x78, 0x78, 0x68, 0x68, 0x59,
	0x68, 0x69, 0x68, 0x59, 0x67, 0x78, 0x59, 0x58, 0x69, 0x59, 0x67, 0x68, 0x67, 0x69, 0x69, 0x57, 0x79, 0x68, 0x59, 0x59,
	0x59, 0x68, 0x68, 0x68, 0x58, 0x78, 0x67, 0x59, 0x68, 0x78, 0x59, 0x58, 0x78, 0x58, 0x76, 0x78, 0x68, 0x68, 0x68, 0x69,
	0x59, 0x67, 0x68, 0x69, 0x59, 0x59, 0x58, 0x69, 0x59, 0x59, 0x58, 0x5A, 0x58, 0x68, 0x68, 0x59, 0x58, 0x68, 0x66, 0x47,
	0x88, 0x77, 0x87, 0x77, 0x87, 0x76, 0x87, 0x87, 0x87, 0x77, 0x77, 0x87, 0x67, 0x96, 0x78, 0x76, 0x87, 0x68, 0x77, 0x77,
	0x76, 0x86, 0x96, 0x86, 0x88, 0x77, 0x85, 0x86, 0x8B, 0x76, 0x0A, 0xF9, 0x07, 0x38, 0x57, 0x67, 0x77, 0x78, 0x77, 0x91,
	0x77, 0xD7, 0x77, 0x7A, 0x67, 0x3C, 0x68, 0x68, 0x77, 0x68, 0x78, 0x59, 0x77, 0x68, 0x77, 0x68, 0x76, 0x77, 0x69, 0x68,
	0x68, 0x68, 0x68, 0x67, 0x68, 0x68, 0x77, 0x87, 0x77, 0x67, 0x78, 0x68, 0x67, 0x58, 0x78, 0x68, 0x77, 0x68, 0x78, 0x67,
	0x68, 0x68, 0x67, 0x78, 0x77, 0x77, 0x87, 0x77, 0x76, 0x67, 0x86, 0x85, 0x87, 0x86, 0x97, 0x58, 0x67, 0x79, 0x57, 0x77,
	0x87, 0x77, 0x87, 0x77, 0x76, 0x59, 0x78, 0x77, 0x77, 0x68, 0x77, 0x77, 0x76, 0x78, 0x77, 0x77, 0x77, 0x76, 0x87, 0x77,
	0x77, 0x68, 0x77, 0x77, 0x77, 0x67, 0x78, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x68, 0x77, 0x76, 0x68, 0x87, 0x77,
	0x77, 0x77, 0x77, 0x68, 0x77, 0x68, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x76, 0x78, 0x77, 0x77, 0x76, 0x87, 0x77, 0x77,
	0x67, 0x78, 0x77, 0x77, 0x76, 0x78, 0x67, 0x68, 0x68, 0x29, 0x77, 0x88, 0x78, 0x78, 0x77, 0x68, 0x77, 0x77, 0x77, 0x77,
	0x77, 0x77, 0x77, 0x77, 0x4A, 0x77, 0x4A, 0x74, 0x77, 0x77, 0x68, 0xA4, 0x7A, 0x47, 0x76, 0x86, 0x78, 0x76, 0x7A, 0x4A,
	0x83, 0xB2, 0x87, 0x77, 0x87, 0x76, 0x96, 0x86, 0x96, 0x76, 0x78, 0x87, 0x77, 0x85, 0x87, 0x85, 0x96, 0x65, 0xB5, 0x95,
	0x96, 0x77, 0x77, 0x86, 0x76, 0x86, 0x86, 0x87, 0x86, 0x86, 0x76, 0x96, 0x96, 0x57, 0x77, 0x85, 0x97, 0x85, 0x86, 0xA5,
	0x86, 0x85, 0x87, 0x77, 0x68, 0x78, 0x77, 0x95, 0x86, 0x75, 0x87, 0x76, 0x86, 0x79, 0x68, 0x84, 0x96, 0x76, 0xB3, 0x87,
	0x77, 0x68, 0x86, 0xA5, 0x77, 0x56, 0xB6, 0x68, 0x85, 0x93, 0xB6, 0x95, 0x95, 0x85, 0x95, 0xA5, 0x95, 0x95, 0x69, 0x85,
	0x95, 0x85, 0x86, 0x86, 0x97, 0x84, 0x85, 0xB6, 0x84, 0xA5, 0x95, 0xA4, 0x95, 0x95, 0x95, 0x68, 0x95, 0x66, 0xA6, 0x95,
	0x95, 0x95, 0x86, 0x93, 0xB5, 0x86, 0x77, 0x94, 0x96, 0x95, 0x96, 0x85, 0x68, 0x94, 0x87, 0x95, 0x86, 0x86, 0x93, 0xB4,
	0xA3, 0xB3, 0xA6, 0x86, 0x85, 0x85, 0x96, 0x76, 0x86, 0x64, 0x69, 0x78, 0x68, 0x78, 0x78, 0x77, 0x67, 0x79, 0x68, 0x79,
	0x59, 0x56, 0x87, 0x98, 0x68, 0x78, 0x76, 0x88, 0x68, 0x68, 0x67, 0x76, 0x87, 0x68, 0x78, 0x76, 0x78, 0x77, 0x78, 0xA6,
	0x80, 0xAF, 0x81, 0x38, 0x47, 0x67, 0x77, 0x78, 0x77, 0x89, 0x07, 0x79, 0xB7, 0x87, 0x86, 0x86, 0x87, 0x86, 0x87, 0x76,
	0x78, 0x77, 0x87, 0x66, 0x96, 0x86, 0x86, 0x74, 0xA6, 0x87, 0x86, 0x77, 0x86, 0x77, 0x76, 0x77, 0x77, 0x87, 0x77, 0x77,
	0x77, 0x77, 0x87, 0x65, 0x78, 0x77, 0x78, 0x75, 0x88, 0x85, 0x76, 0x87, 0x95, 0x77, 0x86, 0x87, 0x86, 0x96, 0x85, 0x76,
	0x69, 0x67, 0x59, 0x77, 0x6A, 0x65, 0x86, 0x78, 0x94, 0x77, 0x88, 0x77, 0x78, 0x85, 0x96, 0x65, 0x98, 0x77, 0x87, 0x67,
	0x86, 0x77, 0x87, 0x66, 0x87, 0x86, 0x86, 0x86, 0x77, 0x86, 0x86, 0x76, 0x87, 0x86, 0x77, 0x76, 0x87, 0x77, 0x86, 0x86,
	0x86, 0x87, 0x76, 0x95, 0x86, 0x86, 0x87, 0x65, 0x97, 0x86, 0x87, 0x76, 0x86, 0x86, 0x87, 0x75, 0x88, 0x76, 0x87, 0x76,
	0x87, 0x76, 0x77, 0x77, 0x86, 0x78, 0x76, 0x76, 0x96, 0x78, 0x76, 0x77, 0x86, 0x77, 0x77, 0x76, 0x96, 0x75, 0x95, 0x56,
	0x87, 0x87, 0x87, 0x78, 0x88, 0x67, 0x87, 0x87, 0x58, 0x87, 0x77, 0x87, 0x77, 0x76, 0x87, 0x96, 0x59, 0x88, 0x37, 0x89,
	0x69, 0x69, 0x84, 0x96, 0x67, 0x77, 0x57, 0x4B, 0x58, 0xB7, 0x80, 0x8E, 0x0D, 0x78, 0x87, 0x77, 0x87, 0x68, 0x79, 0x49,
	0x76, 0x78, 0x77, 0x5A, 0x67, 0x69, 0x68, 0x68, 0x68, 0x4A, 0x68, 0x69, 0x67, 0x69, 0x59, 0x58, 0x68, 0x67, 0x69, 0x77,
	0x77, 0x69, 0x68, 0x68, 0x66, 0x68, 0x87, 0x68, 0x77, 0x5A, 0x68, 0x67, 0x68, 0x68, 0x67, 0x78, 0x78, 0x67, 0x6A, 0x59,
	0x67, 0x57, 0x95, 0x78, 0x77, 0x86, 0x88, 0x57, 0x77, 0x68, 0x67, 0x79, 0x76, 0x76, 0x98, 0x68, 0x75, 0x68, 0x88, 0x58,
	0x87, 0x5A, 0x57, 0x79, 0x67, 0x59, 0x78, 0x49, 0x58, 0x77, 0x79, 0x49, 0x68, 0x59, 0x77, 0x68, 0x78, 0x48, 0x79, 0x67,
	0x68, 0x59, 0x68, 0x68, 0x59, 0x75, 0x6A, 0x68, 0x76, 0x4C, 0x67, 0x77, 0x78, 0x59, 0x69, 0x56, 0x96, 0x68, 0x68, 0x68,
	0x77, 0x69, 0x67, 0x68, 0x67, 0x78, 0x69, 0x68, 0x58, 0x59, 0x68, 0x68, 0x69, 0x49, 0x77, 0x59, 0x67, 0x69, 0x67, 0x68,
	0x65, 0x48, 0x77, 0x87, 0x86, 0x96, 0x88, 0x75, 0x87, 0x96, 0x87, 0x95, 0x87, 0x77, 0x68, 0x86, 0x77, 0x77, 0x96, 0x68,
	0x86, 0x77, 0x85, 0x5A, 0x81, 0xD5, 0x95, 0x68, 0x99, 0x74, 0x98, 0x77, 0x09, 0xF9, 0x0A, 0x5A, 0x66, 0x58, 0x77, 0x87,
	0x91, 0x77, 0x77, 0xE9, 0x77, 0x77, 0x77, 0x76, 0x87, 0x75, 0x97, 0x77, 0x77, 0x77, 0x78, 0x68, 0x68, 0x68, 0x67, 0x3B,
	0x59, 0x77, 0x77, 0x57, 0x79, 0x57, 0x86, 0x87, 0x67, 0x97, 0x77, 0x57, 0x79, 0x77, 0x77, 0x75, 0x95, 0x77, 0x79, 0x75,
	0x97, 0x57, 0x77, 0x79, 0x58, 0x69, 0x77, 0x77, 0x77, 0x77, 0x77, 0x75, 0x86, 0x77, 0x87, 0x58, 0x95, 0x78, 0x65, 0x8A,
	0x39, 0x58, 0x87, 0x96, 0x87, 0x77, 0x77, 0x77, 0x86, 0x87, 0x76, 0x78, 0x77, 0x77, 0x77, 0x68, 0x77, 0x77, 0x77, 0x77,
	0x77, 0x68, 0x77, 0x68, 0x77, 0x67, 0x86, 0x77, 0x78, 0x77, 0x77, 0x77, 0x77, 0x77, 0x68, 0x77, 0x77, 0x77, 0x77, 0x68,
	0x77, 0x68, 0x77, 0x67, 0x78, 0x77, 0x77, 0x68, 0x68, 0x76, 0x87, 0x68, 0x77, 0x77, 0x77, 0x68, 0x77, 0x77, 0x77, 0x77,
	0x77, 0x77, 0x77, 0x68, 0x77, 0x77, 0x77, 0x68, 0x68, 0x68, 0x76, 0x38, 0x97, 0x67, 0x79, 0x77, 0x77, 0x77, 0x77, 0x77,
	0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x78, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x68,
	0x72, 0xC5, 0x86, 0x86, 0x98, 0x77, 0x86, 0x78, 0x1C, 0x85, 0x2E, 0x77, 0x77, 0x77, 0x87, 0x86, 0x76, 0x86, 0x86, 0xA0,
	0xBD, 0x49, 0x97, 0x66, 0x48, 0x88, 0x48, 0x68, 0x86, 0x78, 0x77, 0x77, 0x78, 0x66, 0xA6, 0x87, 0x83, 0x85, 0x88, 0x78,
	0x66, 0xA7, 0x56, 0x87, 0x6A, 0x46, 0x89, 0x76, 0xA7, 0x76, 0x87, 0x74, 0xA2, 0x86, 0x77, 0x79, 0x66, 0xB6, 0x48, 0x67,
	0x8A, 0x36, 0x88, 0x77, 0xA5, 0xA5, 0xB1, 0xE9, 0x39, 0x78, 0x78, 0x75, 0x87, 0x77, 0x77, 0x77, 0x68, 0x58, 0x79, 0x69,
	0x4A, 0x59, 0x29, 0x6A, 0x3C, 0x3B, 0x46, 0x78, 0x75, 0x89, 0x76, 0x89, 0x4A, 0x56, 0x88, 0x3B, 0x66, 0x88, 0x68, 0x87,
	0x57, 0x97, 0x38, 0x87, 0x56, 0xB7, 0x84, 0x88, 0x67, 0x57, 0x95, 0xA8, 0x59, 0x77, 0x68, 0x4A, 0x49, 0x69, 0x57, 0x6A,
	0x59, 0x58, 0x67, 0x87, 0x5A, 0x75, 0x78, 0x69, 0x56, 0x97, 0x77, 0x73, 0x08, 0x78, 0x78, 0x77, 0x87, 0x78, 0x77, 0x78,
	0x77, 0x77, 0x87, 0x78, 0x68, 0x77, 0x77, 0x87, 0x78, 0x76, 0x86, 0x97, 0x58, 0x77, 0x78, 0x58, 0x78, 0x77, 0x68, 0x78,
	0x75, 0x95, 0xB7, 0x70, 0x8F, 0x80, 0xA6, 0x87, 0x65, 0x66, 0x78, 0x7A, 0x17, 0x77, 0x70,
}

func SIT13_Func1(s *SIT13Data, buf []SIT13Buffer, info uint32, bits uint16, num uint16) {
	var i, j uint32

	if bits <= 12 {
		for i = 0; i < (1 << 12); i += (1 << bits) {
			buf[info+i].data = num
			buf[info+i].bits = int8(bits)
		}
	} else {
		j = uint32(bits - 12)

		if buf[info&0xFFF].bits != 0x1F {
			buf[info&0xFFF].bits = 0x1F
			buf[info&0xFFF].data = s.MaxBits
			s.MaxBits++
		}
		bits = buf[info&0xFFF].data
		info >>= 12

		for range j {
			var a *uint16

			if info&1 != 0 {
				a = &s.Buffer4[bits].d2
			} else {
				a = &s.Buffer4[bits].d1
			}
			if *a == 0 {
				*a = s.MaxBits
				s.MaxBits++
			}
			bits = *a
			info >>= 1
		}
		s.Buffer4[bits].freq = int16(num)
	}
}

func SIT13_SortTree(s *SIT13Data, buf []SIT13Buffer) {
	buf1, buf2 := 0, len(buf)

	for buf2-1 > buf1 {
		a, b := buf1, buf2

		for {
			for {
				a++
				if a >= buf2 {
					break
				}
				tb := buf[a].bits - buf[buf1].bits
				if tb > 0 || (tb == 0 && (buf[a].data >= buf[buf1].data)) {
					break
				}
			}
			for {
				b--
				if b <= buf1 {
					break
				}
				tb := buf[b].bits - buf[buf1].bits
				if tb < 0 || (tb == 0 && (buf[b].data <= buf[buf1].data)) {
					break
				}
			}
			if b < a {
				break
			} else {
				buf[a], buf[b] = buf[b], buf[a]
			}
		}
		if b == buf1 {
			buf1++
		} else {
			buf[buf1], buf[b] = buf[b], buf[buf1]
			if buf2-b-1 > b-buf1 {
				SIT13_SortTree(s, buf[buf1:b])
				buf1 = b + 1
			} else {
				SIT13_SortTree(s, buf[b+1:buf2])
				buf2 = b
			}
		}
	}
}

func SIT13_Func2(s *SIT13Data, buf []SIT13Buffer, bits uint16, buf2 []SIT13Buffer) {
	var i, j, k, l, m, n int32

	SIT13_SortTree(s, buf2[:bits])

	for i = 0; i < int32(bits); i++ {
		l += k
		m = int32(buf2[i].bits)
		if m != j {
			j = m
			if j == -1 {
				k = 0
			} else {
				k = 1 << (32 - j)
			}
		}
		if j > 0 {
			m = 0
			for n = 0; n < 8*4; n += 4 {
				m += int32(SIT13Bits[(l>>n)&0xF]) << (7*4 - n)
			}
			SIT13_Func1(s, buf, uint32(m), uint16(j), buf2[i].data)
		}
	}
}

func SIT13_CreateStaticTree(s *SIT13Data, buf []SIT13Buffer, bits uint16, bitsbuf []uint8) {
	for i := range bits {
		s.Buffer5[i].data = i
		s.Buffer5[i].bits = int8(bitsbuf[i])
	}
	SIT13_Func2(s, buf, bits, s.Buffer5[:])
}

func SIT13InitInfo(s *SIT13Data, id uint8) {
	var k, l uint8

	a := s.TextBuf[:]
	b := SIT13Static[SIT13StaticPos[id-1]:]
	id &= 1

	for i := 658; i != 0; i-- {
		if id != 0 {
			k = b[0] >> 4
		} else {
			k = b[0] & 0xF
			b = b[1:]
		}
		id ^= 1

		if k == 0 {
			if id != 0 {
				l -= b[0] >> 4
			} else {
				l -= b[0] & 0xF
				b = b[1:]
			}
			id ^= 1
		} else {
			if k == 15 {
				if id != 0 {
					l += b[0] >> 4
				} else {
					l += b[0] & 0xF
					b = b[1:]
				}
				id ^= 1
			} else {
				l += k - 7
			}
		}
		a[0] = l
		a = a[1:]
	}
}

func SIT13_CreateTree(s *SIT13Data, bitbuf int, buf []SIT13Buffer, num uint16) int {
	var b *SIT13Buffer
	var data uint16
	var bi int8 = 0

	for i := uint16(0); i < num; i++ { // note the loop body changes i
		bitbuf = FillLittleEndian(bitbuf, s.br) // guaranteed 55 bits, enough for a loop iteration

		bits := bitbuf & (1<<12 - 1)
		b = &Buffer1[bits]
		data = b.data
		bitbuf >>= b.bits
		switch data - 0x1F {
		case 0:
			bi = -1
		case 1:
			bi++
		case 2:
			bi--
		case 3:
			field := bitbuf & 1
			bitbuf >>= 1
			if field != 0 {
				s.Buffer5[i].bits = bi
				i++
			}
		case 4:
			field := bitbuf&(1<<3-1) + 2
			bitbuf >>= 3
			for range field {
				s.Buffer5[i].bits = bi
				i++
			}
		case 5:
			field := bitbuf&(1<<6-1) + 10
			bitbuf >>= 6
			for range field {
				s.Buffer5[i].bits = bi
				i++
			}
		default:
			bi = int8(data + 1)
		}
		s.Buffer5[i].bits = bi
	}
	for i := range num {
		s.Buffer5[i].data = i
	}
	SIT13_Func2(s, buf, num, s.Buffer5[:])
	return bitbuf
}

func sit13(r io.Reader, dstsize int64) io.ReadCloser {
	pr, pw := io.Pipe()
	go sit13copy(pw, r, dstsize)
	return pr
}

func sit13copy(dst *io.PipeWriter, src io.Reader, dstsize int64) {
	defer func() {
		if r := recover(); r != nil {
			dst.CloseWithError(fmt.Errorf("internal StuffIt panic: %v", r))
		} else {
			dst.Close()
		}
	}()

	var s SIT13Data
	s.br = bufio.NewReaderSize(src, 1024)
	bw := bufio.NewWriterSize(dst, 1024)
	defer bw.Flush()

	var i, j uint32
	s.MaxBits = 1
	clear(Buffer1[:])
	for i := range 37 {
		SIT13_Func1(&s, Buffer1[:], uint32(SIT13Info[i]), SIT13InfoBits[i], uint16(i))
	}

	for i = 1; i < 0x704; i++ {
		/* s.Buffer4[i].d1 = s.Buffer4[i].d2 = 0; */
		s.Buffer4[i].freq = -1
	}

	bitbuf := FillLittleEndian(InitialLittleEndian, s.br)
	j = uint32(bitbuf) & 0xff
	bitbuf >>= 8
	i = j >> 4
	if i > 5 {
		panic("XADERR_ILLEGALDATA")
	} else if i != 0 {
		SIT13InitInfo(&s, uint8(i))
		i--
		SIT13_CreateStaticTree(&s, s.Buffer3[:], 0x141, s.TextBuf[:])
		SIT13_CreateStaticTree(&s, s.Buffer3b[:], 0x141, s.TextBuf[0x141:])
		SIT13_CreateStaticTree(&s, s.Buffer2[:], uint16(SIT13StaticBits[i]), s.TextBuf[0x282:])
	} else {
		bitbuf = SIT13_CreateTree(&s, bitbuf, s.Buffer3[:], 0x141)
		if j&8 != 0 {
			copy(s.Buffer3b[:], s.Buffer3[:])
		} else {
			bitbuf = SIT13_CreateTree(&s, bitbuf, s.Buffer3b[:], 0x141)
		}
		j = (j & 7) + 10
		bitbuf = SIT13_CreateTree(&s, bitbuf, s.Buffer2[:], uint16(j))
	}

	var wpos, l, size uint32
	buf := s.Buffer3[:]

	for {
		bitbuf = FillLittleEndian(bitbuf, s.br)
		// now guaranteed 55 bits
		k := uint32(bitbuf & (1<<12 - 1)) // not sure of type?
		j := buf[k].bits
		if j <= 12 {
			l = uint32(buf[k].data)
			bitbuf >>= j
			// now guaranteed 43 bits
		} else {
			bitbuf >>= 12

			j := buf[k].data
			for s.Buffer4[j].freq == -1 {
				bit := bitbuf & 1
				bitbuf >>= 1
				if bit != 0 {
					j = s.Buffer4[j].d2
				} else {
					j = s.Buffer4[j].d1
				}
				bitbuf = FillLittleEndian(bitbuf, s.br)
			}
			// now guaranteed 55 bits
			l = uint32(s.Buffer4[j].freq)
		}
		// now guaranteed 43 bits
		if l < 0x100 {
			if bw.WriteByte(byte(l)) != nil {
				return
			}
			dstsize--
			if dstsize == 0 {
				return
			}
			s.Window[wpos] = byte(l)
			wpos++
			wpos &= 0xFFFF
			buf = s.Buffer3[:]
		} else {
			buf = s.Buffer3b[:]
			if l < 0x13E {
				size = l - 0x100 + 3
			} else {
				if l == 0x13E {
					size = uint32(bitbuf & (1<<10 - 1))
					bitbuf >>= 10
					// now guaranteed 33 bits
				} else {
					if l == 0x140 {
						return
					}
					size = uint32(bitbuf & (1<<15 - 1))
					bitbuf >>= 15
					// now guaranteed 28 bits
				}
				size += 65
			}
			// now guaranteed 28 bits
			j2 := uint32(bitbuf & (1<<12 - 1))
			k = uint32(s.Buffer2[j2].bits)
			if k <= 12 {
				l = uint32(s.Buffer2[j2].data)
				bitbuf >>= k
				// now guaranteed 16 bits
			} else {
				bitbuf >>= k
				// now guaranteed 16 bits
				j2 = uint32(s.Buffer2[j2].data)
				for s.Buffer4[j2].freq == -1 {
					bit := bitbuf & 1
					bitbuf >>= 1
					if bit != 0 {
						j2 = uint32(s.Buffer4[j2].d2)
					} else {
						j2 = uint32(s.Buffer4[j2].d1)
					}
					bitbuf = FillLittleEndian(bitbuf, s.br)
				}
				// now guaranteed 55 bits
				l = uint32(s.Buffer4[j2].freq)
			}
			// now guaranteed 16 bits
			k = 0
			if l != 0 {
				l--
				k = (1 << l) | uint32((bitbuf & (1<<l - 1)))
				bitbuf >>= l
			}
			l = wpos + 0x10000 - (k + 1)
			for range size {
				l &= 0xFFFF // this could very likely be optimised
				if bw.WriteByte(s.Window[l]) != nil {
					return
				}
				dstsize--
				if dstsize == 0 {
					return
				}
				s.Window[wpos] = s.Window[l]
				wpos++
				l++
				wpos &= 0xFFFF
			}
		} /* l >= 0x100 */
	}
}
